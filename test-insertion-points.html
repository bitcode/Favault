<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Folder Insertion Points</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .test-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            backdrop-filter: blur(10px);
        }
        
        .folder-container {
            margin-bottom: 2rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            overflow: hidden;
            padding: 1rem;
        }
        
        .folder-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
        }
        
        .drag-handle {
            width: 20px;
            height: 20px;
            color: rgba(255, 255, 255, 0.5);
            cursor: grab;
        }
        
        .folder-title {
            font-size: 1.2rem;
            font-weight: 600;
        }

        /* Enhanced folder dragging styles */
        .folder-container {
            transition: all 0.3s ease;
            cursor: grab;
        }

        .folder-container:active {
            cursor: grabbing;
        }

        .folder-container[draggable="true"]:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 255, 255, 0.2);
        }

        /* Dragging state styles */
        .folder-container.dragging {
            opacity: 0.6;
            transform: rotate(2deg) scale(0.95);
            z-index: 1000;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        }

        /* Global drag active state */
        .drag-active {
            user-select: none;
        }

        .drag-active .folder-container:not(.dragging) {
            opacity: 0.8;
        }
        
        /* Insertion point styles */
        .insertion-point {
            height: 8px;
            margin: 0.5rem 0;
            position: relative;
            transition: all 0.3s ease;
            opacity: 0.3;
        }

        .insertion-point.first {
            margin-top: 0;
        }

        .insertion-point.last {
            margin-bottom: 0;
        }

        /* Enhanced visibility during edit mode */
        .edit-mode .insertion-point {
            opacity: 0.6;
            height: 12px;
        }

        /* Hover state */
        .insertion-point:hover {
            height: 40px;
            opacity: 1;
            margin: 1rem 0;
        }

        /* Drag over state */
        .insertion-point.drag-over {
            height: 50px;
            opacity: 1;
            margin: 1.5rem 0;
            z-index: 100;
        }

        /* Global drag active state - all insertion points become visible */
        .drag-active .insertion-point {
            height: 35px;
            opacity: 0.8;
            margin: 1rem 0;
        }

        /* Enhanced drag active state for edit mode */
        .edit-mode.drag-active .insertion-point {
            height: 45px;
            opacity: 0.9;
            margin: 1.2rem 0;
        }

        /* Specific drag over state takes precedence */
        .drag-active .insertion-point.drag-over {
            height: 60px;
            opacity: 1;
            margin: 1.5rem 0;
            z-index: 200;
        }

        .insertion-line {
            width: 100%;
            height: 100%;
            border: 2px dashed transparent;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            background: rgba(59, 130, 246, 0.05);
        }

        /* Enhanced line visibility in edit mode */
        .edit-mode .insertion-line {
            border-color: rgba(59, 130, 246, 0.3);
            background: rgba(59, 130, 246, 0.08);
        }

        /* Hover state styling */
        .insertion-point:hover .insertion-line {
            border-color: #3b82f6;
            background: rgba(59, 130, 246, 0.12);
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.2);
        }

        /* Drag active state styling */
        .drag-active .insertion-line {
            border-color: rgba(59, 130, 246, 0.6);
            background: rgba(59, 130, 246, 0.1);
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.15);
        }

        /* Drag over state styling */
        .insertion-point.drag-over .insertion-line {
            border-color: #3b82f6;
            border-width: 3px;
            background: rgba(59, 130, 246, 0.2);
            box-shadow: 0 0 25px rgba(59, 130, 246, 0.3);
            animation: pulse-insertion 1.5s ease-in-out infinite;
        }

        .insertion-indicator {
            display: none;
            align-items: center;
            gap: 0.5rem;
            color: #3b82f6;
            font-size: 0.875rem;
            font-weight: 500;
            opacity: 0.9;
            white-space: nowrap;
        }

        /* Show indicators on hover */
        .insertion-point:hover .insertion-indicator {
            display: flex;
        }

        /* Show indicators during drag operations */
        .drag-active .insertion-indicator {
            display: flex;
            opacity: 0.7;
        }

        /* Enhanced indicators for drag over */
        .insertion-point.drag-over .insertion-indicator {
            display: flex;
            opacity: 1;
            font-weight: 600;
        }

        .insertion-indicator svg {
            width: 16px;
            height: 16px;
        }

        @keyframes pulse-insertion {
            0%, 100% {
                box-shadow: 0 0 25px rgba(59, 130, 246, 0.3);
                transform: scale(1);
            }
            50% {
                box-shadow: 0 0 35px rgba(59, 130, 246, 0.5);
                transform: scale(1.02);
            }
        }
        
        .test-controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
        }
        
        button {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: white;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        button:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .status {
            background: rgba(0, 0, 0, 0.2);
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Folder Insertion Points Test</h1>
        
        <div class="test-section">
            <h2>Test Controls</h2>
            <div class="test-controls">
                <button onclick="toggleEditMode()">Toggle Edit Mode</button>
                <button onclick="highlightInsertionPoints()">Highlight Insertion Points</button>
                <button onclick="simulateDrag()">Simulate Drag</button>
                <button onclick="testDragDrop()">Setup Drag & Drop</button>
            </div>
            <div class="test-controls">
                <button onclick="runComprehensiveTest()">Run Comprehensive Test</button>
                <button onclick="testAllPositions()">Test All Positions</button>
                <button onclick="showCurrentOrder()">Show Current Order</button>
                <button onclick="stressTestReordering()">Stress Test Reordering</button>
            </div>
            <div class="test-controls">
                <button onclick="resetFolderOrder()">Reset to Original Order</button>
                <button onclick="debugDOMState()">Debug DOM State</button>
                <button onclick="location.reload()">Reload Page</button>
            </div>
            <div id="status" class="status">Ready for testing...</div>
        </div>
        
        <div class="test-section">
            <h2>Folder List with Insertion Points</h2>
            <div id="bookmarks-container" class="bookmarks-container">
                <!-- Insertion point before first folder -->
                <div class="insertion-point first" data-insertion-index="0">
                    <div class="insertion-line">
                        <div class="insertion-indicator">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                <path d="M12 5v14M5 12l7-7 7 7"/>
                            </svg>
                            <span>Drop folder here (Position 1)</span>
                        </div>
                    </div>
                </div>

                <!-- Folder 1 -->
                <div class="folder-container" draggable="true" data-folder-index="0">
                    <div class="folder-header">
                        <div class="drag-handle">⋮⋮</div>
                        <div class="folder-title">Work Bookmarks</div>
                    </div>
                </div>

                <!-- Insertion point after folder 1 -->
                <div class="insertion-point" data-insertion-index="1">
                    <div class="insertion-line">
                        <div class="insertion-indicator">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                <path d="M12 5v14M5 12l7-7 7 7"/>
                            </svg>
                            <span>Drop folder here (Position 2)</span>
                        </div>
                    </div>
                </div>

                <!-- Folder 2 -->
                <div class="folder-container" draggable="true" data-folder-index="1">
                    <div class="folder-header">
                        <div class="drag-handle">⋮⋮</div>
                        <div class="folder-title">Personal Bookmarks</div>
                    </div>
                </div>

                <!-- Insertion point after folder 2 -->
                <div class="insertion-point" data-insertion-index="2">
                    <div class="insertion-line">
                        <div class="insertion-indicator">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                <path d="M12 5v14M5 12l7-7 7 7"/>
                            </svg>
                            <span>Drop folder here (Position 3)</span>
                        </div>
                    </div>
                </div>

                <!-- Folder 3 -->
                <div class="folder-container" draggable="true" data-folder-index="2">
                    <div class="folder-header">
                        <div class="drag-handle">⋮⋮</div>
                        <div class="folder-title">Development Resources</div>
                    </div>
                </div>

                <!-- Insertion point after folder 3 -->
                <div class="insertion-point" data-insertion-index="3">
                    <div class="insertion-line">
                        <div class="insertion-indicator">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                <path d="M12 5v14M5 12l7-7 7 7"/>
                            </svg>
                            <span>Drop folder here (Position 4)</span>
                        </div>
                    </div>
                </div>

                <!-- Folder 4 -->
                <div class="folder-container" draggable="true" data-folder-index="3">
                    <div class="folder-header">
                        <div class="drag-handle">⋮⋮</div>
                        <div class="folder-title">Entertainment</div>
                    </div>
                </div>

                <!-- Insertion point after folder 4 -->
                <div class="insertion-point" data-insertion-index="4">
                    <div class="insertion-line">
                        <div class="insertion-indicator">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                <path d="M12 5v14M5 12l7-7 7 7"/>
                            </svg>
                            <span>Drop folder here (Position 5)</span>
                        </div>
                    </div>
                </div>

                <!-- Folder 5 -->
                <div class="folder-container" draggable="true" data-folder-index="4">
                    <div class="folder-header">
                        <div class="drag-handle">⋮⋮</div>
                        <div class="folder-title">Shopping & Finance</div>
                    </div>
                </div>

                <!-- Insertion point after folder 5 (last) -->
                <div class="insertion-point last" data-insertion-index="5">
                    <div class="insertion-line">
                        <div class="insertion-indicator">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                <path d="M12 5v14M5 12l7-7 7 7"/>
                            </svg>
                            <span>Drop folder here (Position 6)</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        let editMode = false;
        let currentDragData = null;
        let isDragging = false;
        let draggedElement = null;
        let eventListenerRegistry = new Map(); // Track event listeners for proper cleanup

        function updateStatus(message) {
            document.getElementById('status').textContent = message;
            console.log('📊 Status:', message);
        }

        function toggleEditMode() {
            editMode = !editMode;
            const container = document.getElementById('bookmarks-container');
            if (editMode) {
                container.classList.add('edit-mode');
                updateStatus('Edit mode enabled - insertion points should be more visible');
            } else {
                container.classList.remove('edit-mode');
                updateStatus('Edit mode disabled');
            }
        }

        function highlightInsertionPoints() {
            const insertionPoints = document.querySelectorAll('.insertion-point');
            updateStatus(`Highlighting ${insertionPoints.length} insertion points...`);

            insertionPoints.forEach((point, index) => {
                const insertionIndex = point.getAttribute('data-insertion-index');

                // Add temporary highlighting with position labels
                point.style.background = 'rgba(255, 0, 0, 0.4)';
                point.style.border = '3px solid red';
                point.style.height = '50px';
                point.style.opacity = '1';
                point.style.margin = '1rem 0';

                // Add position label
                const label = document.createElement('div');
                label.textContent = `Insertion Point ${insertionIndex}`;
                label.style.cssText = `
                    position: absolute;
                    top: -25px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: red;
                    color: white;
                    padding: 4px 8px;
                    border-radius: 4px;
                    font-size: 12px;
                    z-index: 1000;
                    pointer-events: none;
                    white-space: nowrap;
                `;
                point.style.position = 'relative';
                point.appendChild(label);

                console.log(`📍 Highlighted insertion point ${index} (insertion-index=${insertionIndex})`);
            });

            setTimeout(() => {
                insertionPoints.forEach(point => {
                    point.style.background = '';
                    point.style.border = '';
                    point.style.height = '';
                    point.style.opacity = '';
                    point.style.margin = '';

                    // Remove label
                    const label = point.querySelector('div[style*="position: absolute"]');
                    if (label && label.parentNode === point) {
                        point.removeChild(label);
                    }
                });
                updateStatus('Insertion point highlighting completed');
            }, 5000);
        }

        function simulateDrag() {
            const folders = document.querySelectorAll('.folder-container');
            const container = document.getElementById('bookmarks-container');

            if (folders.length === 0) {
                updateStatus('No folders found');
                return;
            }

            updateStatus('Simulating drag operation...');

            // Simulate drag start on first folder
            const firstFolder = folders[0];
            const folderTitle = firstFolder.querySelector('.folder-title').textContent;

            // Apply dragging styles to folder
            firstFolder.style.opacity = '0.6';
            firstFolder.style.transform = 'rotate(2deg) scale(0.95)';
            firstFolder.style.zIndex = '1000';
            firstFolder.style.boxShadow = '0 10px 25px rgba(0, 0, 0, 0.3)';

            // Activate global drag state
            container.classList.add('drag-active');
            isDragging = true;

            updateStatus(`Dragging "${folderTitle}" - all insertion points should be visible`);

            // Simulate drag over different insertion points
            const insertionPoints = document.querySelectorAll('.insertion-point');
            let currentIndex = 0;

            const simulateDragOver = () => {
                // Remove previous drag-over
                insertionPoints.forEach(point => point.classList.remove('drag-over'));

                if (currentIndex < insertionPoints.length) {
                    const currentPoint = insertionPoints[currentIndex];
                    currentPoint.classList.add('drag-over');

                    const insertionIndex = currentPoint.getAttribute('data-insertion-index');
                    updateStatus(`Dragging over insertion point ${insertionIndex} (${currentIndex + 1}/${insertionPoints.length})`);

                    currentIndex++;
                    setTimeout(simulateDragOver, 1000);
                } else {
                    // End simulation
                    setTimeout(() => {
                        firstFolder.style.opacity = '';
                        firstFolder.style.transform = '';
                        firstFolder.style.zIndex = '';
                        firstFolder.style.boxShadow = '';

                        container.classList.remove('drag-active');
                        insertionPoints.forEach(point => point.classList.remove('drag-over'));
                        isDragging = false;

                        updateStatus('Drag simulation completed - all insertion points tested');
                    }, 500);
                }
            };

            // Start the simulation
            setTimeout(simulateDragOver, 500);
        }
        
        function testDragDrop() {
            updateStatus('Setting up enhanced drag and drop event listeners...');

            const container = document.getElementById('bookmarks-container');
            const folders = document.querySelectorAll('.folder-container');
            const insertionPoints = document.querySelectorAll('.insertion-point');

            // Setup drag event listeners for folders (will be refreshed after reordering)
            setupFolderDragListeners();
        }

        function clearAllEventListeners() {
            console.log('🧹 Clearing all event listeners...');

            // Clear tracked event listeners
            eventListenerRegistry.forEach((listeners, element) => {
                listeners.forEach(({ event, handler }) => {
                    element.removeEventListener(event, handler);
                });
            });
            eventListenerRegistry.clear();

            console.log('✅ Event listeners cleared');
        }

        function addTrackedEventListener(element, event, handler) {
            // Add event listener and track it for cleanup
            element.addEventListener(event, handler);

            if (!eventListenerRegistry.has(element)) {
                eventListenerRegistry.set(element, []);
            }
            eventListenerRegistry.get(element).push({ event, handler });
        }

        function setupFolderDragListeners() {
            const container = document.getElementById('bookmarks-container');

            // Clear all existing event listeners more safely
            clearAllEventListeners();

            // Get fresh references
            const folders = container.querySelectorAll('.folder-container');
            const insertionPoints = container.querySelectorAll('.insertion-point');

            console.log(`🔧 Setting up listeners for ${folders.length} folders and ${insertionPoints.length} insertion points`);

            // Add drag event listeners to folders
            folders.forEach((folder, index) => {
                const dragStartHandler = (e) => {
                    // Get current index from DOM position
                    const currentIndex = Array.from(container.querySelectorAll('.folder-container')).indexOf(folder);

                    currentDragData = {
                        type: 'folder',
                        index: currentIndex,
                        title: folder.querySelector('.folder-title').textContent
                    };

                    e.dataTransfer.setData('application/x-favault-bookmark', JSON.stringify(currentDragData));
                    e.dataTransfer.effectAllowed = 'move';

                    // Apply dragging styles
                    folder.style.opacity = '0.6';
                    folder.style.transform = 'rotate(2deg) scale(0.95)';
                    folder.style.zIndex = '1000';

                    // Activate global drag state
                    container.classList.add('drag-active');
                    isDragging = true;
                    draggedElement = folder;

                    updateStatus(`Started dragging: "${currentDragData.title}" (current position ${currentIndex + 1}) - insertion points should now be visible`);

                    console.log('🎯 Drag started:', currentDragData);
                    console.log('📍 Insertion points should be visible:', insertionPoints.length);
                };

                const dragEndHandler = (e) => {
                    // Reset folder styles
                    folder.style.opacity = '';
                    folder.style.transform = '';
                    folder.style.zIndex = '';

                    // Deactivate global drag state
                    container.classList.remove('drag-active');
                    isDragging = false;
                    draggedElement = null;

                    // Clean up insertion points
                    const currentInsertionPoints = container.querySelectorAll('.insertion-point');
                    currentInsertionPoints.forEach(point => {
                        point.classList.remove('drag-over');
                    });

                    updateStatus('Drag ended - insertion points should return to normal');
                    console.log('🎯 Drag ended');
                };

                addTrackedEventListener(folder, 'dragstart', dragStartHandler);
                addTrackedEventListener(folder, 'dragend', dragEndHandler);
            });

            // Add drop event listeners to insertion points
            insertionPoints.forEach((point, pointIndex) => {
                const dragOverHandler = (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                };

                const dragEnterHandler = (e) => {
                    e.preventDefault();

                    if (isDragging && currentDragData) {
                        point.classList.add('drag-over');
                        const insertionIndex = point.getAttribute('data-insertion-index');
                        console.log(`🎯 Drag enter insertion point ${insertionIndex}`);
                    }
                };

                const dragLeaveHandler = (e) => {
                    // Only remove drag-over if we're actually leaving the insertion point
                    if (!point.contains(e.relatedTarget)) {
                        point.classList.remove('drag-over');
                        const insertionIndex = point.getAttribute('data-insertion-index');
                        console.log(`🎯 Drag leave insertion point ${insertionIndex}`);
                    }
                };

                const dropHandler = (e) => {
                    e.preventDefault();
                    point.classList.remove('drag-over');

                    const insertionIndex = parseInt(point.getAttribute('data-insertion-index'));

                    if (currentDragData) {
                        updateStatus(`✅ Dropped "${currentDragData.title}" at insertion point ${insertionIndex} (Position ${insertionIndex + 1})`);

                        // Simulate successful drop with visual feedback
                        point.style.background = 'rgba(0, 255, 0, 0.4)';
                        point.style.border = '3px solid green';
                        point.style.height = '50px';
                        point.style.opacity = '1';

                        // Log the reordering operation
                        console.log(`✅ REORDER: "${currentDragData.title}" (from index ${currentDragData.index}) → insertion point ${insertionIndex}`);

                        // Simulate folder reordering in the UI
                        setTimeout(() => {
                            simulateFolderReorder(currentDragData.index, insertionIndex);
                        }, 500);

                        // Reset visual feedback
                        setTimeout(() => {
                            point.style.background = '';
                            point.style.border = '';
                            point.style.height = '';
                            point.style.opacity = '';
                        }, 2000);
                    }
                };

                addTrackedEventListener(point, 'dragover', dragOverHandler);
                addTrackedEventListener(point, 'dragenter', dragEnterHandler);
                addTrackedEventListener(point, 'dragleave', dragLeaveHandler);
                addTrackedEventListener(point, 'drop', dropHandler);
            });

            updateStatus(`✅ Enhanced drag and drop listeners added for ${folders.length} folders and ${insertionPoints.length} insertion points!`);
            console.log(`🎯 Setup complete: ${folders.length} folders, ${insertionPoints.length} insertion points`);
        }

        function simulateFolderReorder(fromIndex, toInsertionIndex) {
            const container = document.getElementById('bookmarks-container');
            const folders = Array.from(container.querySelectorAll('.folder-container'));

            if (fromIndex >= 0 && fromIndex < folders.length) {
                const folderToMove = folders[fromIndex];
                const folderTitle = folderToMove.querySelector('.folder-title').textContent;

                updateStatus(`🔄 Reordering: Moving "${folderTitle}" from position ${fromIndex + 1} to insertion point ${toInsertionIndex}`);
                console.log(`🔄 Starting DOM reorder: ${fromIndex} → insertion point ${toInsertionIndex}`);

                // Actually reorder the DOM elements
                const success = reorderFoldersInDOM(fromIndex, toInsertionIndex);

                if (success) {
                    // Refresh drag listeners after DOM changes
                    setTimeout(() => {
                        setupFolderDragListeners();
                        updateStatus(`✅ Folder "${folderTitle}" successfully moved to insertion point ${toInsertionIndex} - listeners refreshed`);

                        // Verify the new order
                        setTimeout(() => {
                            showCurrentOrder();
                        }, 100);
                    }, 300);
                } else {
                    updateStatus(`❌ Failed to reorder folder "${folderTitle}"`);
                    console.error('❌ Reordering failed');
                }
            } else {
                updateStatus(`❌ Invalid folder index: ${fromIndex}`);
                console.error(`❌ Invalid folder index: ${fromIndex} (total folders: ${folders.length})`);
            }
        }

        function reorderFoldersInDOM(fromIndex, toInsertionIndex) {
            const container = document.getElementById('bookmarks-container');

            console.log(`🔄 DOM Reorder: Starting reorder from ${fromIndex} to insertion point ${toInsertionIndex}`);

            // Get current state
            const folders = Array.from(container.querySelectorAll('.folder-container'));
            const insertionPoints = Array.from(container.querySelectorAll('.insertion-point'));

            // Validate indices
            if (fromIndex < 0 || fromIndex >= folders.length) {
                console.error(`❌ Invalid fromIndex: ${fromIndex} (folders: ${folders.length})`);
                return false;
            }

            if (toInsertionIndex < 0 || toInsertionIndex >= insertionPoints.length) {
                console.error(`❌ Invalid toInsertionIndex: ${toInsertionIndex} (insertion points: ${insertionPoints.length})`);
                return false;
            }

            const folderToMove = folders[fromIndex];
            const folderTitle = folderToMove.querySelector('.folder-title').textContent;
            const targetInsertionPoint = insertionPoints[toInsertionIndex];

            console.log(`🔄 Moving "${folderTitle}" from position ${fromIndex} to insertion point ${toInsertionIndex}`);

            // Create a complete new folder order
            const newFolderOrder = [...folders];

            // Remove the folder from its current position
            newFolderOrder.splice(fromIndex, 1);

            // Calculate the correct insertion position
            let insertPosition = toInsertionIndex;

            // If moving to a position after the original position, adjust for the removal
            if (toInsertionIndex > fromIndex) {
                insertPosition = toInsertionIndex - 1;
            }

            // Insert the folder at the new position
            newFolderOrder.splice(insertPosition, 0, folderToMove);

            console.log(`🔄 New order calculated: insertion position ${insertPosition}`);

            // Rebuild the DOM structure completely
            rebuildContainerDOM(newFolderOrder);

            // Add visual feedback for the moved folder
            folderToMove.style.background = 'rgba(0, 255, 0, 0.2)';
            folderToMove.style.border = '2px solid green';
            folderToMove.style.transform = 'scale(1.05)';

            // Remove visual feedback after animation
            setTimeout(() => {
                folderToMove.style.background = '';
                folderToMove.style.border = '';
                folderToMove.style.transform = '';
            }, 2000);

            console.log(`✅ DOM Reorder complete: "${folderTitle}" moved to position ${insertPosition}`);
            return true;
        }

        function rebuildContainerDOM(newFolderOrder) {
            const container = document.getElementById('bookmarks-container');

            console.log('🔧 Rebuilding container DOM with new folder order...');

            // Clear the container completely
            container.innerHTML = '';

            // Rebuild with proper insertion point structure
            newFolderOrder.forEach((folder, index) => {
                // Create insertion point before this folder
                const insertionPoint = createInsertionPoint(index, index === 0, false);
                container.appendChild(insertionPoint);

                // Add the folder
                container.appendChild(folder);
            });

            // Add final insertion point after the last folder
            const finalInsertionPoint = createInsertionPoint(newFolderOrder.length, false, true);
            container.appendChild(finalInsertionPoint);

            // Update folder indices
            updateFolderIndices();

            console.log(`✅ Container rebuilt with ${newFolderOrder.length} folders and ${newFolderOrder.length + 1} insertion points`);
        }

        function createInsertionPoint(insertionIndex, isFirst, isLast) {
            const insertionPoint = document.createElement('div');
            insertionPoint.className = 'insertion-point';
            if (isFirst) insertionPoint.classList.add('first');
            if (isLast) insertionPoint.classList.add('last');
            insertionPoint.setAttribute('data-insertion-index', insertionIndex);

            const insertionLine = document.createElement('div');
            insertionLine.className = 'insertion-line';

            const insertionIndicator = document.createElement('div');
            insertionIndicator.className = 'insertion-indicator';

            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('viewBox', '0 0 24 24');
            svg.setAttribute('fill', 'none');
            svg.setAttribute('stroke', 'currentColor');

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', 'M12 5v14M5 12l7-7 7 7');
            svg.appendChild(path);

            const span = document.createElement('span');
            span.textContent = `Drop folder here (Position ${insertionIndex + 1})`;

            insertionIndicator.appendChild(svg);
            insertionIndicator.appendChild(span);
            insertionLine.appendChild(insertionIndicator);
            insertionPoint.appendChild(insertionLine);

            return insertionPoint;
        }

        function updateFolderIndices() {
            const container = document.getElementById('bookmarks-container');
            const folders = container.querySelectorAll('.folder-container');

            folders.forEach((folder, index) => {
                folder.setAttribute('data-folder-index', index);
                console.log(`📁 Updated folder ${index}: "${folder.querySelector('.folder-title').textContent}"`);
            });

            console.log(`📊 Updated ${folders.length} folder indices`);
        }

        function showCurrentOrder() {
            const container = document.getElementById('bookmarks-container');
            const folders = container.querySelectorAll('.folder-container');

            console.log('📊 Current folder order:');
            updateStatus('📊 Current folder order (check console for details):');

            const orderList = [];
            folders.forEach((folder, index) => {
                const title = folder.querySelector('.folder-title').textContent;
                const dataIndex = folder.getAttribute('data-folder-index');
                orderList.push(`${index + 1}. ${title}`);
                console.log(`  ${index + 1}. "${title}" (data-index: ${dataIndex})`);
            });

            // Update status with current order
            setTimeout(() => {
                updateStatus(`📊 Current order: ${orderList.join(' → ')}`);
            }, 100);

            return orderList;
        }

        function resetFolderOrder() {
            updateStatus('🔄 Resetting folder order to original...');

            const container = document.getElementById('bookmarks-container');

            // Define original order
            const originalFolders = [
                'Work Bookmarks',
                'Personal Bookmarks',
                'Development Resources',
                'Entertainment',
                'Shopping & Finance'
            ];

            // Get current folders
            const folders = Array.from(container.querySelectorAll('.folder-container'));

            // Sort folders by original order
            folders.sort((a, b) => {
                const titleA = a.querySelector('.folder-title').textContent;
                const titleB = b.querySelector('.folder-title').textContent;
                const indexA = originalFolders.indexOf(titleA);
                const indexB = originalFolders.indexOf(titleB);
                return indexA - indexB;
            });

            // Remove all folders from DOM
            folders.forEach(folder => folder.remove());

            // Re-insert folders in original order after their respective insertion points
            const insertionPoints = container.querySelectorAll('.insertion-point');
            folders.forEach((folder, index) => {
                if (insertionPoints[index]) {
                    insertionPoints[index].insertAdjacentElement('afterend', folder);
                }
            });

            // Update indices and refresh listeners
            updateFolderIndices();
            setupFolderDragListeners();

            updateStatus('✅ Folder order reset to original');
            console.log('✅ Folder order reset to original');
        }

        function debugDOMState() {
            const container = document.getElementById('bookmarks-container');
            const folders = container.querySelectorAll('.folder-container');
            const insertionPoints = container.querySelectorAll('.insertion-point');

            console.log('🔍 DEBUG: Current DOM State');
            console.log(`📁 Folders: ${folders.length}`);
            console.log(`📍 Insertion Points: ${insertionPoints.length}`);

            folders.forEach((folder, index) => {
                const title = folder.querySelector('.folder-title').textContent;
                const dataIndex = folder.getAttribute('data-folder-index');
                console.log(`  📁 ${index}: "${title}" (data-index: ${dataIndex})`);
            });

            insertionPoints.forEach((point, index) => {
                const insertionIndex = point.getAttribute('data-insertion-index');
                const isFirst = point.classList.contains('first');
                const isLast = point.classList.contains('last');
                console.log(`  📍 ${index}: insertion-index=${insertionIndex}, first=${isFirst}, last=${isLast}`);
            });

            console.log(`🎯 Event listeners tracked: ${eventListenerRegistry.size} elements`);
            console.log(`🎯 Current drag state: isDragging=${isDragging}, currentDragData=`, currentDragData);

            updateStatus(`🔍 Debug info logged - ${folders.length} folders, ${insertionPoints.length} insertion points`);
        }

        function stressTestReordering() {
            updateStatus('🧪 Starting stress test - multiple reordering operations...');
            console.log('🧪 Starting stress test...');

            const operations = [
                { from: 0, to: 2, description: 'Move first folder to position 3' },
                { from: 2, to: 0, description: 'Move folder back to first position' },
                { from: 4, to: 1, description: 'Move last folder to position 2' },
                { from: 1, to: 4, description: 'Move folder back to last position' },
                { from: 2, to: 3, description: 'Move middle folder one position right' },
                { from: 3, to: 2, description: 'Move folder back one position left' }
            ];

            let currentOperation = 0;

            const executeNextOperation = () => {
                if (currentOperation < operations.length) {
                    const op = operations[currentOperation];
                    console.log(`🧪 Stress test ${currentOperation + 1}/${operations.length}: ${op.description}`);
                    updateStatus(`🧪 Stress test ${currentOperation + 1}/${operations.length}: ${op.description}`);

                    // Simulate the reordering
                    simulateFolderReorder(op.from, op.to);

                    currentOperation++;

                    // Wait before next operation
                    setTimeout(() => {
                        debugDOMState();
                        setTimeout(executeNextOperation, 1000);
                    }, 1500);
                } else {
                    updateStatus('✅ Stress test completed - check console for any issues');
                    console.log('✅ Stress test completed');

                    // Final verification
                    setTimeout(() => {
                        debugDOMState();
                        showCurrentOrder();
                    }, 500);
                }
            };

            executeNextOperation();
        }
        
        // Comprehensive test function
        function runComprehensiveTest() {
            updateStatus('🧪 Running comprehensive insertion points test...');

            const folders = document.querySelectorAll('.folder-container');
            const insertionPoints = document.querySelectorAll('.insertion-point');

            console.log('🧪 Starting comprehensive test...');
            console.log(`📁 Found ${folders.length} folders`);
            console.log(`📍 Found ${insertionPoints.length} insertion points`);

            // Test 1: Verify insertion point count
            const expectedInsertionPoints = folders.length + 1;
            if (insertionPoints.length === expectedInsertionPoints) {
                console.log('✅ Test 1 PASSED: Correct number of insertion points');
            } else {
                console.log(`❌ Test 1 FAILED: Expected ${expectedInsertionPoints}, found ${insertionPoints.length}`);
            }

            // Test 2: Verify insertion point attributes
            let attributeTestPassed = true;
            insertionPoints.forEach((point, index) => {
                const insertionIndex = point.getAttribute('data-insertion-index');
                if (parseInt(insertionIndex) !== index) {
                    console.log(`❌ Test 2 FAILED: Insertion point ${index} has wrong insertion-index: ${insertionIndex}`);
                    attributeTestPassed = false;
                }
            });
            if (attributeTestPassed) {
                console.log('✅ Test 2 PASSED: All insertion points have correct attributes');
            }

            // Test 3: Test edit mode visibility
            if (!editMode) {
                toggleEditMode();
            }

            setTimeout(() => {
                const container = document.getElementById('bookmarks-container');
                const hasEditMode = container.classList.contains('edit-mode');
                if (hasEditMode) {
                    console.log('✅ Test 3 PASSED: Edit mode activated correctly');
                } else {
                    console.log('❌ Test 3 FAILED: Edit mode not activated');
                }

                // Test 4: Test drag state activation
                setTimeout(() => {
                    container.classList.add('drag-active');

                    setTimeout(() => {
                        const visiblePoints = Array.from(insertionPoints).filter(point => {
                            const style = window.getComputedStyle(point);
                            return parseFloat(style.height) > 20; // Should be expanded during drag
                        });

                        if (visiblePoints.length === insertionPoints.length) {
                            console.log('✅ Test 4 PASSED: All insertion points visible during drag state');
                        } else {
                            console.log(`❌ Test 4 FAILED: Only ${visiblePoints.length}/${insertionPoints.length} insertion points visible during drag`);
                        }

                        container.classList.remove('drag-active');

                        updateStatus('🧪 Comprehensive test completed - check console for results');
                        console.log('🧪 Comprehensive test completed');
                    }, 500);
                }, 500);
            }, 500);
        }

        // Test all positions function
        function testAllPositions() {
            updateStatus('🧪 Testing all insertion point positions...');

            const insertionPoints = document.querySelectorAll('.insertion-point');
            let currentIndex = 0;

            const testNextPosition = () => {
                if (currentIndex < insertionPoints.length) {
                    const point = insertionPoints[currentIndex];
                    const insertionIndex = point.getAttribute('data-insertion-index');

                    // Highlight current position
                    point.style.background = 'rgba(0, 255, 255, 0.4)';
                    point.style.border = '3px solid cyan';
                    point.style.height = '50px';
                    point.style.opacity = '1';
                    point.style.margin = '1rem 0';

                    updateStatus(`Testing position ${currentIndex + 1}/${insertionPoints.length}: Insertion index ${insertionIndex}`);
                    console.log(`🧪 Testing insertion point ${currentIndex}: insertion-index=${insertionIndex}`);

                    setTimeout(() => {
                        // Reset styles
                        point.style.background = '';
                        point.style.border = '';
                        point.style.height = '';
                        point.style.opacity = '';
                        point.style.margin = '';

                        currentIndex++;
                        testNextPosition();
                    }, 1000);
                } else {
                    updateStatus('✅ All insertion point positions tested successfully');
                    console.log('✅ All positions tested');
                }
            };

            testNextPosition();
        }

        // Initialize
        updateStatus('Test page loaded. Use controls above to test insertion points.');
        console.log('🧪 Insertion Points Test Page Loaded');
        console.log('Available test functions:');
        console.log('  - toggleEditMode()');
        console.log('  - highlightInsertionPoints()');
        console.log('  - simulateDrag()');
        console.log('  - testDragDrop()');
        console.log('  - runComprehensiveTest()');
        console.log('  - testAllPositions()');
        console.log('  - showCurrentOrder()');
        console.log('  - resetFolderOrder()');
        console.log('  - debugDOMState()');

        // Show initial folder order and debug state
        setTimeout(() => {
            showCurrentOrder();
            debugDOMState();
        }, 500);

        // Auto-setup drag and drop
        setTimeout(() => {
            testDragDrop();
        }, 1000);
    </script>
</body>
</html>
